From eff9e5755e9ab604351f3d05f067dc04a021277e Mon Sep 17 00:00:00 2001
From: Tobias Schramm <t.schramm@t-sys.eu>
Date: Sun, 21 Mar 2021 23:44:19 +0100
Subject: [PATCH 8/8] ASoC: add support for gpio configuration on TAS5825M

Signed-off-by: Tobias Schramm <t.schramm@t-sys.eu>
---
 .../devicetree/bindings/sound/tas5825m.yaml   | 14 ++++
 sound/soc/codecs/tas5825m.c                   | 76 ++++++++++++++++++-
 2 files changed, 89 insertions(+), 1 deletion(-)

diff --git a/Documentation/devicetree/bindings/sound/tas5825m.yaml b/Documentation/devicetree/bindings/sound/tas5825m.yaml
index 6431cbf92d0b..b094531b94e9 100644
--- a/Documentation/devicetree/bindings/sound/tas5825m.yaml
+++ b/Documentation/devicetree/bindings/sound/tas5825m.yaml
@@ -36,6 +36,20 @@ properties:
   shutdown-gpios:
     description: GPIO used to control the state of the device.
 
+  tas5825m,gpio0-func:
+    description: output function of gpio0 on the TAS5825M
+    enum:
+      - gpio
+      - auto-mute
+      - auto-mute-left
+      - auto-mute-right
+      - clock-invalid
+      - warn
+      - sdout
+      - fault
+      - spi-clk
+      - spi-mosi
+
   '#sound-dai-cells':
     const: 0
 
diff --git a/sound/soc/codecs/tas5825m.c b/sound/soc/codecs/tas5825m.c
index 264ad67fb8da..67ac04b08599 100644
--- a/sound/soc/codecs/tas5825m.c
+++ b/sound/soc/codecs/tas5825m.c
@@ -618,6 +618,75 @@ static struct snd_soc_dai_driver tas5825m_dai[] = {
 	},
 };
 
+struct tas5825m_gpio_func {
+	char *name;
+	unsigned mux;
+};
+
+struct tas5825m_gpio_func tas5825m_gpio_fuctions[] = {
+	{ "gpio",		0b0010 },
+	{ "auto-mute",		0b0011 },
+	{ "auto-mute-left",	0b0100 },
+	{ "auto-mute-right",	0b0101 },
+	{ "clock-invalid",	0b0110 },
+	{ "warn",		0b1000 },
+	{ "sdout",		0b1001 },
+	{ "fault",		0b1011 },
+	{ "spi-clk",		0b1100 },
+	{ "spi-mosi",		0b1101 }
+};
+
+static int tas5825m_get_gpio_func_by_name(const char *name) {
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tas5825m_gpio_fuctions); i++) {
+		struct tas5825m_gpio_func *func = &tas5825m_gpio_fuctions[i];
+
+		if (!strcmp(name, func->name)) {
+			return func->mux;
+		}
+	}
+
+	return -1;
+}
+
+static int tas5825m_gpio_init(struct tas5825m_data *tas) {
+#if IS_ENABLED(CONFIG_OF)
+	struct device *dev = &tas->tas5825m_client->dev;
+	int i;
+
+	for (i = 0; i <= 2; i++) {
+		char propname[32];
+		const char *funcname;
+		int err, mux;
+
+		snprintf(propname, sizeof(propname), "tas5825m,gpio%d-func", i);
+		if (!of_find_property(dev->of_node, propname, NULL)) {
+			continue;
+		}
+
+		err = of_property_read_string(dev->of_node, propname, &funcname);
+		if (err) {
+			dev_err(dev, "failed to read property %s\n", propname);
+			return err;
+		}
+
+		mux = tas5825m_get_gpio_func_by_name(funcname);
+		if (mux < 0) {
+			dev_err(dev, "invalid mux setting %s for gpio%d\n", funcname, i);
+			return -EINVAL;
+		}
+
+		err = regmap_write(tas->regmap, TAS5825M_GPIO0_SEL + i, mux);
+		if (err < 0) {
+			dev_err(dev, "failed to write mux setting 0x%02x for gpio%d\n", mux, i);
+			return err;
+		}
+	}
+#endif
+	return 0;
+};
+
 static int tas5825m_probe(struct i2c_client *client)
 {
 	struct device *dev = &client->dev;
@@ -648,7 +717,6 @@ static int tas5825m_probe(struct i2c_client *client)
 		return ret;
 	}
 
-
 	data->shutdown_gpio = devm_gpiod_get_optional(dev, "pdn", GPIOD_OUT_LOW);
 	if (IS_ERR(data->shutdown_gpio)) {
 		ret = PTR_ERR(data->shutdown_gpio);
@@ -656,6 +724,12 @@ static int tas5825m_probe(struct i2c_client *client)
 		return ret;
 	}
 
+	ret = tas5825m_gpio_init(data);
+	if (ret) {
+		dev_err(dev, "failed to initialize gpios: %d\n", ret);
+		return ret;
+	}
+
 	dev_set_drvdata(dev, data);
 
 	ret = devm_snd_soc_register_component(&client->dev,
-- 
2.30.1

