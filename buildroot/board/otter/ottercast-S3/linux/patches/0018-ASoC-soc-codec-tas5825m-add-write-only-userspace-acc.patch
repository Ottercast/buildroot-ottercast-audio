From beb681477a2c7cd6c74fa3535c005ea7abf26fe0 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <t.schramm@t-sys.eu>
Date: Fri, 16 Apr 2021 21:29:28 +0200
Subject: [PATCH 18/18] ASoC: soc: codec: tas5825m: add write-only userspace
 access to DSP registers

The TAS5825M is a digital-input class D power amplifier with an integrated
DSP. Currently the DSP goes unused, since the only supported mode of
configuration is through C header files generated by a proprietary TI tool.
To enable use of the DSP this patch adds a sysfs file that allows write
access to the DSP registers within the codec specifically.

Signed-off-by: Tobias Schramm <t.schramm@t-sys.eu>
---
 sound/soc/codecs/tas5825m.c | 206 +++++++++++++++++++++++++++++++++++-
 sound/soc/codecs/tas5825m.h |   4 +-
 2 files changed, 204 insertions(+), 6 deletions(-)

diff --git a/sound/soc/codecs/tas5825m.c b/sound/soc/codecs/tas5825m.c
index 9679fdcb71bf..08f5ef678245 100644
--- a/sound/soc/codecs/tas5825m.c
+++ b/sound/soc/codecs/tas5825m.c
@@ -38,13 +38,15 @@ static const char * const tas5825m_supply_names[] = {
 struct tas5825m_data {
 	struct snd_soc_component *component;
 	struct regmap *regmap;
-	struct i2c_client *tas5825m_client;
+	struct i2c_client *i2c_client;
 	struct regulator_bulk_data supplies[TAS5825M_NUM_SUPPLIES];
 	struct delayed_work fault_check_work;
 	struct gpio_desc *shutdown_gpio;
 	unsigned int last_chan_fault;
 	unsigned int last_global_fault1;
 	unsigned int last_global_fault2;
+	u8 register_book;
+	u8 register_page;
 };
 
 static int tas5825m_hw_params(struct snd_pcm_substream *substream,
@@ -543,10 +545,132 @@ static bool tas5825m_is_volatile_reg(struct device *dev, unsigned int reg)
 	}
 }
 
+static int i2c_read_reg(struct i2c_client *i2c, u8 reg, u8 *val) {
+	struct i2c_msg xfer[2];
+	int ret;
+
+	xfer[0].addr = i2c->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 1;
+	xfer[0].buf = (void *)&reg;
+
+	xfer[1].addr = i2c->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = 1;
+	xfer[1].buf = val;
+
+	ret = i2c_transfer(i2c->adapter, xfer, 2);
+	if (ret == 2)
+		return 0;
+	else if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static int i2c_write_reg(struct i2c_client *i2c, u8 reg, u8 val) {
+	struct i2c_msg xfer;
+	int ret;
+	u8 data[] = { reg, val };
+
+	xfer.addr = i2c->addr;
+	xfer.flags = 0;
+	xfer.len = sizeof(data);
+	xfer.buf = (void *)data;
+
+	ret = i2c_transfer(i2c->adapter, &xfer, 1);
+	if (ret == 1)
+		return 0;
+	else if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static int tas_set_book_and_page(struct tas5825m_data *tas, u8 book, u8 page) {
+	int err;
+
+	if (tas->register_book == book && tas->register_page == page) {
+		return 0;
+	}
+
+	err = i2c_write_reg(tas->i2c_client, TAS5825M_PAGE, 0x00);
+	if (err) {
+		dev_err(&tas->i2c_client->dev,
+			"Failed to set page to 0x00: %d\n", err);
+		return err;
+	}
+	tas->register_page = 0;
+
+	err = i2c_write_reg(tas->i2c_client, TAS5825M_BOOK, book);
+	if (err) {
+		dev_err(&tas->i2c_client->dev,
+			"Failed to set book to 0x%02x: %d\n", book, err);
+		return err;
+	}
+	tas->register_book = book;
+
+	err = i2c_write_reg(tas->i2c_client, TAS5825M_PAGE, page);
+	if (err) {
+		dev_err(&tas->i2c_client->dev,
+			"Failed to set page to 0x%02x: %d\n", page, err);
+		return err;
+	}
+	tas->register_page = page;
+
+	return 0;
+}
+
+static int tas_read_reg(void *ctx, unsigned int reg, unsigned int *val) {
+	int err;
+	struct tas5825m_data *tas = ctx;
+	u8 book, page, val8;
+
+	book = (reg >> 16) & 0xff;
+	page = (reg >> 8) & 0xff;
+	err = tas_set_book_and_page(tas, book, page);
+	if (err) {
+		dev_err(&tas->i2c_client->dev,
+			"Failed to set book/page: %d\n", err);
+		return err;
+	}
+
+	err = i2c_read_reg(tas->i2c_client, reg & 0xff, &val8);
+	if (!err) {
+		*val = val8;
+	}
+	return err;
+}
+
+static int tas_write_reg(void *ctx, unsigned int reg, unsigned int val) {
+	int err;
+	struct tas5825m_data *tas = ctx;
+	u8 book, page;
+
+	book = (reg >> 16) & 0xff;
+	page = (reg >> 8) & 0xff;
+	err = tas_set_book_and_page(tas, book, page);
+	if (err) {
+		dev_err(&tas->i2c_client->dev,
+			"Failed to set book/page: %d\n", err);
+		return err;
+	}
+
+	return i2c_write_reg(tas->i2c_client, reg & 0xff, val & 0xff);
+}
+
 static const struct regmap_config tas5825m_regmap_config = {
-	.reg_bits = 8,
+	/*
+	 * register address:
+	 *    book      page     reg
+	 * [23 ... 16|15 ... 8|7 ... 0]
+	 */
+	.reg_bits = 24,
 	.val_bits = 8,
 
+	.reg_read = tas_read_reg,
+	.reg_write = tas_write_reg,
+
 	.max_register = TAS5825M_MAX_REG,
 	.cache_type = REGCACHE_RBTREE,
 	.volatile_reg = tas5825m_is_volatile_reg,
@@ -676,7 +800,7 @@ static int tas5825m_get_gpio_func_by_name(const char *name) {
 
 static int tas5825m_gpio_init(struct tas5825m_data *tas) {
 #if IS_ENABLED(CONFIG_OF)
-	struct device *dev = &tas->tas5825m_client->dev;
+	struct device *dev = &tas->i2c_client->dev;
 	int i;
 
 	for (i = 0; i <= 2; i++) {
@@ -711,6 +835,65 @@ static int tas5825m_gpio_init(struct tas5825m_data *tas) {
 	return 0;
 };
 
+static int dsp_register_write(struct tas5825m_data *tas, u8 book, u8 page, u8 reg, u8 value) {
+	unsigned int reg_addr = ((unsigned int)book << 16) | ((unsigned int)page << 8) | reg;
+
+	if (book == 0 && page == 0) {
+		if (reg != TAS5825M_DSP_PGM_MODE &&
+		    reg != TAS5825M_DSP_CTRL &&
+		    reg != TAS5825M_ANA_CTRL &&
+		    reg != TAS5825M_DEVICE_CTRL2) {
+			return -EACCES;
+		}
+
+		/* Allow access to DIS_DSP bit only */
+		if (reg == TAS5825M_DEVICE_CTRL2) {
+			return regmap_write_bits(tas->regmap, reg_addr, TAS5825M_DIS_DSP, value);
+		}
+	}
+
+	return regmap_write(tas->regmap, reg_addr, value);
+}
+
+static ssize_t dsp_registers_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct tas5825m_data *tas = dev_get_drvdata(dev);
+	char strbuf[32];
+	char *strptr = strbuf;
+	unsigned long book, page, reg, value;
+	int err;
+
+	if (count >= sizeof(strbuf))
+		return -EINVAL;
+
+	memcpy(strbuf, buf, count);
+	strbuf[count] = 0;
+
+	while (*strptr == ' ')
+		strptr++;
+	book = simple_strtoul(strptr, &strptr, 16);
+	while (*strptr == ' ')
+		strptr++;
+	page = simple_strtoul(strptr, &strptr, 16);
+	while (*strptr == ' ')
+		strptr++;
+	reg = simple_strtoul(strptr, &strptr, 16);
+	while (*strptr == ' ')
+		strptr++;
+	if (kstrtoul(strptr, 16, &value))
+		return -EINVAL;
+
+	err = dsp_register_write(tas, book, page, reg, value);
+	if (err < 0) {
+		return err;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR_WO(dsp_registers);
+
 static int tas5825m_probe(struct i2c_client *client)
 {
 	struct device *dev = &client->dev;
@@ -722,9 +905,9 @@ static int tas5825m_probe(struct i2c_client *client)
 	if (!data)
 		return -ENOMEM;
 
-	data->tas5825m_client = client;
+	data->i2c_client = client;
 
-	data->regmap = devm_regmap_init_i2c(client, &tas5825m_regmap_config);
+	data->regmap = devm_regmap_init(dev, NULL, data, &tas5825m_regmap_config);
 	if (IS_ERR(data->regmap)) {
 		ret = PTR_ERR(data->regmap);
 		dev_err(dev, "failed to allocate register map: %d\n", ret);
@@ -765,6 +948,18 @@ static int tas5825m_probe(struct i2c_client *client)
 		return ret;
 	}
 
+	ret = device_create_file(&client->dev, &dev_attr_dsp_registers);
+	if (ret) {
+		dev_err(dev, "failed to create dsp register file: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tas5825m_remove(struct i2c_client *client) {
+	device_remove_file(&client->dev, &dev_attr_dsp_registers);
+
 	return 0;
 }
 
@@ -782,6 +977,7 @@ static struct i2c_driver tas5825m_i2c_driver = {
 		.of_match_table = of_match_ptr(tas5825m_of_match),
 	},
 	.probe_new = tas5825m_probe,
+	.remove = tas5825m_remove,
 };
 
 module_i2c_driver(tas5825m_i2c_driver);
diff --git a/sound/soc/codecs/tas5825m.h b/sound/soc/codecs/tas5825m.h
index 1d0ed056cd32..2a648af7d37a 100644
--- a/sound/soc/codecs/tas5825m.h
+++ b/sound/soc/codecs/tas5825m.h
@@ -10,6 +10,7 @@
 #define __TAS5825M_H__
 
 /* Register Address Map */
+#define TAS5825M_PAGE			0x00
 #define TAS5825M_RESET_CTRL		0x01
 #define TAS5825M_DEVICE_CTRL1		0x02
 #define TAS5825M_DEVICE_CTRL2		0x03
@@ -67,7 +68,8 @@
 #define TAS5825M_MISC_CONTROL		0x76
 #define TAS5825M_CBC_CONTROL		0x77
 #define TAS5825M_FAULT_CLEAR		0x78
-#define TAS5825M_MAX_REG		TAS5825M_FAULT_CLEAR
+#define TAS5825M_BOOK			0x7f
+#define TAS5825M_MAX_REG		0xffffff
 
 
 /* TAS5825M_RESET_CTRL */
-- 
2.30.1

