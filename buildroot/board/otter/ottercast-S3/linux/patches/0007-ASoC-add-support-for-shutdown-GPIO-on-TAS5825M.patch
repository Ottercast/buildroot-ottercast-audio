From 2d0d3efff5710818b7dc18bb39aae191ae5d7773 Mon Sep 17 00:00:00 2001
From: Tobias Schramm <t.schramm@t-sys.eu>
Date: Sun, 21 Mar 2021 21:04:32 +0100
Subject: [PATCH 7/7] ASoC: add support for shutdown GPIO on TAS5825M

Signed-off-by: Tobias Schramm <t.schramm@t-sys.eu>
---
 .../devicetree/bindings/sound/tas5825m.yaml   |  4 ++
 sound/soc/codecs/tas5825m.c                   | 41 +++++++++++++------
 2 files changed, 33 insertions(+), 12 deletions(-)

diff --git a/Documentation/devicetree/bindings/sound/tas5825m.yaml b/Documentation/devicetree/bindings/sound/tas5825m.yaml
index 7d3bcf4a47e3..6431cbf92d0b 100644
--- a/Documentation/devicetree/bindings/sound/tas5825m.yaml
+++ b/Documentation/devicetree/bindings/sound/tas5825m.yaml
@@ -33,6 +33,9 @@ properties:
     description:
       regulator phandle for the main VDD amplifier power supply
 
+  shutdown-gpios:
+    description: GPIO used to control the state of the device.
+
   '#sound-dai-cells':
     const: 0
 
@@ -55,6 +58,7 @@ examples:
        #sound-dai-cells = <0>;
        dvdd-supply = <&vcc_3v3>;
        pvdd-supply = <&vbus>;
+       shutdown-gpios = <&pio 4 5 GPIO_ACTIVE_HIGH>;
      };
    };
 
diff --git a/sound/soc/codecs/tas5825m.c b/sound/soc/codecs/tas5825m.c
index afcc460c1191..264ad67fb8da 100644
--- a/sound/soc/codecs/tas5825m.c
+++ b/sound/soc/codecs/tas5825m.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/device.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
@@ -40,6 +41,7 @@ struct tas5825m_data {
 	struct i2c_client *tas5825m_client;
 	struct regulator_bulk_data supplies[TAS5825M_NUM_SUPPLIES];
 	struct delayed_work fault_check_work;
+	struct gpio_desc *shutdown_gpio;
 	unsigned int last_chan_fault;
 	unsigned int last_global_fault1;
 	unsigned int last_global_fault2;
@@ -395,6 +397,11 @@ static int tas5825m_dac_event(struct snd_soc_dapm_widget *w,
 
 	if (event & SND_SOC_DAPM_POST_PMU) {
 		/* Take TAS5825M out of shutdown mode */
+		if (tas5825m->shutdown_gpio) {
+			gpiod_set_value(tas5825m->shutdown_gpio, 1);
+			msleep(10);
+		}
+
 		ret = snd_soc_component_update_bits(component, TAS5825M_DEVICE_CTRL2,
 					  TAS5825M_CTRL_STATE_MASK, TAS5825M_CTRL_STATE_HIZ);
 		if (ret < 0) {
@@ -440,7 +447,7 @@ static int tas5825m_dac_event(struct snd_soc_dapm_widget *w,
 					  TAS5825M_DIS_DSP,
 					  TAS5825M_DIS_DSP);
 		if (ret < 0) {
-			dev_err(component->dev, "error waking DSP: %d\n", ret);
+			dev_err(component->dev, "error disabling DSP: %d\n", ret);
 			return ret;
 		}
 
@@ -454,6 +461,11 @@ static int tas5825m_dac_event(struct snd_soc_dapm_widget *w,
 				ret);
 			return ret;
 		}
+
+		if (tas5825m->shutdown_gpio) {
+			gpiod_set_value(tas5825m->shutdown_gpio, 0);
+			msleep(10);
+		}
 	}
 
 	return 0;
@@ -468,6 +480,9 @@ static int tas5825m_suspend(struct snd_soc_component *component)
 	regcache_cache_only(tas5825m->regmap, true);
 	regcache_mark_dirty(tas5825m->regmap);
 
+	if (tas5825m->shutdown_gpio)
+		gpiod_set_value(tas5825m->shutdown_gpio, 1);
+
 	ret = regulator_bulk_disable(ARRAY_SIZE(tas5825m->supplies),
 				     tas5825m->supplies);
 	if (ret < 0)
@@ -488,6 +503,9 @@ static int tas5825m_resume(struct snd_soc_component *component)
 		return ret;
 	}
 
+	if (tas5825m->shutdown_gpio)
+		gpiod_set_value(tas5825m->shutdown_gpio, 1);
+
 	regcache_cache_only(tas5825m->regmap, false);
 
 	ret = regcache_sync(tas5825m->regmap);
@@ -582,7 +600,6 @@ static const struct snd_soc_component_driver soc_component_dev_tas5825m = {
 static const struct snd_soc_dai_ops tas5825m_speaker_dai_ops = {
 	.hw_params	= tas5825m_hw_params,
 	.set_fmt	= tas5825m_set_dai_fmt,
-//	.set_tdm_slot	= tas5825m_set_dai_tdm_slot, TODO: implement
 	.mute_stream	= tas5825m_mute,
 	.no_capture_mute = 1,
 };
@@ -601,8 +618,7 @@ static struct snd_soc_dai_driver tas5825m_dai[] = {
 	},
 };
 
-static int tas5825m_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
+static int tas5825m_probe(struct i2c_client *client)
 {
 	struct device *dev = &client->dev;
 	struct tas5825m_data *data;
@@ -632,6 +648,14 @@ static int tas5825m_probe(struct i2c_client *client,
 		return ret;
 	}
 
+
+	data->shutdown_gpio = devm_gpiod_get_optional(dev, "pdn", GPIOD_OUT_LOW);
+	if (IS_ERR(data->shutdown_gpio)) {
+		ret = PTR_ERR(data->shutdown_gpio);
+		dev_err(dev, "failed to request powerdown gpio: %d\n", ret);
+		return ret;
+	}
+
 	dev_set_drvdata(dev, data);
 
 	ret = devm_snd_soc_register_component(&client->dev,
@@ -646,12 +670,6 @@ static int tas5825m_probe(struct i2c_client *client,
 	return 0;
 }
 
-static const struct i2c_device_id tas5825m_id[] = {
-	{ "tas5825m", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(i2c, tas5825m_id);
-
 #if IS_ENABLED(CONFIG_OF)
 static const struct of_device_id tas5825m_of_match[] = {
 	{ .compatible = "ti,tas5825m", },
@@ -665,8 +683,7 @@ static struct i2c_driver tas5825m_i2c_driver = {
 		.name = "tas5825m",
 		.of_match_table = of_match_ptr(tas5825m_of_match),
 	},
-	.probe = tas5825m_probe,
-	.id_table = tas5825m_id,
+	.probe_new = tas5825m_probe,
 };
 
 module_i2c_driver(tas5825m_i2c_driver);
-- 
2.30.1

